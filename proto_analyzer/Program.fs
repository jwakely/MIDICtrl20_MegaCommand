// Learn more about F# at http://fsharp.org

open System
open System.IO
open System.Threading
open System.IO.Ports
open A4Cmds
open A4Types
open Microsoft.FSharp.Text.StructuredFormat
open Microsoft.FSharp.Text.StructuredFormat.LayoutOps
open Newtonsoft.Json
open System

type TargetDevice =
| AnalogFour
| MonoMachine

let mutable dev = MonoMachine

let blockL sep_l sep_r (xs: Layout list) =
    aboveListL [
    sepL sep_l @@-
        List.reduce (@@) xs
    sepL sep_r
    ]

let pairL k v =
    wordL k ^^ sepL ":" ^^ objL v

let byteL = sprintf "0x%02x"
let bytesL xs = sprintf "%A" <| List.map byteL xs

let fmt l = Display.layout_to_string FormatOptions.Default l

[<StructuredFormatDisplay("{Str}")>]
type CommunicationRecord = 
    {
        cmd:        byte;
        parameters: byte list;
        response:   byte list;
        send_time:  DateTime;
        recv_time:  DateTime;
    }
    with 
    [<JsonIgnore>]
    member x.Str = 
        let layout = blockL "{" "}" [
            pairL "cmd" (byteL x.cmd)
            pairL "params" (bytesL x.parameters)
            pairL "response" (bytesL x.response)
            pairL "rspLen" (List.length x.response)
        ]
        fmt layout

let communicate (com: SerialPort) (input: int list) : CommunicationRecord = 
    match dev, input with
    | _, [] -> failwith "empty input"
    | AnalogFour, cmd :: _ when List.contains cmd A4_BAD_COMMANDS -> failwith "bad command"
    | _, cmd :: parameters ->
    let request = 
        if dev = AnalogFour then 
            [
                // begin sysex
                [ 0xf0 ]
                // A4 header
                [ 0x00; 0x20; 0x3c; 0x06; 0x00 ]
                // command
                [ cmd ]
                // a4 proto. ver.
                [ 0x01; 0x01 ]
                // the rest of input
                parameters
                // a4 proto. endframe
                [ 0x00; 0x00; 0x00; 0x05]
                // end sysex
                [ 0xf7 ]
            ]
        else 
            [
                // begin sysex
                [ 0xf0 ]
                // MonoMachine header
                [ 0x00; 0x20; 0x3c; 0x03; 0x00 ]
                // command
                [ cmd ]
                // the rest of input
                parameters
                // end sysex
                [ 0xf7 ]
            ]
        |> List.concat
        |> List.map byte
        |> List.toArray
    let send_time = DateTime.Now
    com.Write(request, 0, Array.length request)

    // read until first timeout
    let rec __read_exhaustive data = 
        let read_byte = 
            try com.ReadByte() |> byte |> Some
            with | :? TimeoutException -> None
        match read_byte with
        | Some x -> 
            __read_exhaustive(x :: data)
        | None ->
          {
            cmd = byte(cmd)
            parameters = List.map byte parameters
            send_time = send_time
            recv_time = DateTime.Now
            response = List.rev data |> List.skipWhile (fun x -> x <> 0xf0uy) // skip the noise generated by keystrokes etc.
          }
    __read_exhaustive []

let rng = new System.Random()
let rand() = rng.Next(0, 128)
type GenT =
| Random
| Fixed of data: int list * editing: int

let synthesize_payload len =
    [for _ in 1..len -> rand()]

let rec probe com dat cmd len r =
    let len = max 0 <| min len 6
    let cmd = max 0 <| min cmd 127
    let r = match r with
            | Fixed(dat, i) when List.length dat <> len -> 
                let makeup = max 0 <| len - List.length dat
                let dat_append = List.append <| List.truncate len dat
                Fixed(dat_append (List.init makeup (fun _ -> 0)), max 0 <| min i (List.length dat - 1))
            | Fixed(dat, i) -> Fixed(dat, max 0 <| min i (List.length dat - 1))
            | _ -> r

    let request = cmd :: match r with   
                         | Random -> synthesize_payload len
                         | Fixed(dat, _) -> dat

    let ui_col = 90

    let mk_comm() = 
        try
            Console.SetCursorPosition(ui_col, 4)
            printf "= BUSY ="
            let record = communicate com request
            record :: dat
        with
        | ex -> 
            printfn "cmd=0x%02x: %s" cmd ex.Message
            dat

    Console.Clear()
    let history = List.truncate 1 dat
    history |> List.iter (printfn "%A")
    Console.SetCursorPosition(ui_col, 0)
    printf "Current cmd = 0x%02x; Len = %A" cmd len
    Console.SetCursorPosition(ui_col, 1)
    printf "Current dat = "
    let ith_pos i = ui_col + 14 + i * 3
    request |> List.iteri (fun i x -> Console.SetCursorPosition(ith_pos i, 1); printf "%02x" x)

    match r with
    | Fixed(_, i) ->
      Console.SetCursorPosition(2 + ith_pos i+2, 2)
      printf("^")
    | _ -> ()

    let probe' = probe com dat
    let k = Console.ReadKey().Key

    Thread.Sleep(10)

    let plus  i i' x = if i <> i' then x else x+1
    let minus i i' x = if i <> i' then x else x-1
    let zero  i i' x = if i <> i' then x else 0

    match k, r with
    | ConsoleKey.Escape, _        -> List.rev dat
    | ConsoleKey.Enter, _         -> probe com (mk_comm()) cmd len r
    | ConsoleKey.PageDown, _      -> probe' (cmd+1) len r
    | ConsoleKey.PageUp, _        -> probe' (cmd-1) len r
    | ConsoleKey.Home, _          -> probe' cmd (len-1) r
    | ConsoleKey.End, _           -> probe' cmd (len+1) r
    | ConsoleKey.Spacebar, Random -> probe' cmd len <| Fixed(synthesize_payload len, 0)
    | ConsoleKey.Spacebar, Fixed _-> probe' cmd len Random
    | _, Fixed(dat, i) ->
      let dat, i = 
          match k with
          | ConsoleKey.UpArrow    -> List.mapi (plus i)  dat, i
          | ConsoleKey.DownArrow  -> List.mapi (minus i) dat, i
          | ConsoleKey.LeftArrow  -> dat, i-1
          | ConsoleKey.RightArrow -> dat, i+1
          | ConsoleKey.D0         -> List.mapi (zero i) dat, i+1
          | _                     -> dat, i
      probe' cmd len <| Fixed(dat, i)
    | _                      -> probe' cmd len r
       
let slice i n = List.truncate n << List.skip i
let chop i n = List.map <| slice i n

let hexprint =
    function
    | 0uy -> Console.ForegroundColor <- ConsoleColor.DarkGray 
             printf "%02x " 0
             Console.ForegroundColor <- ConsoleColor.White 
    | x   -> printf "%02x " x
 
let rec recall (dat: byte list list) x y =
    let n_rows = Console.WindowHeight - 6
    let n_cols = Console.WindowWidth / 3 - 5

    let y' = max 0 <| min y (List.length dat - 1)
    let x' = max 0 <| min x (List.min <| List.map (fun x -> List.length x - 1) dat)

    if x <> x' || y <> y' 
    then Console.Clear()

    let x, y = x', y'

    Console.SetCursorPosition(6, 0)
    [1..n_cols] |> List.iter (fun i ->
        if i % 4 = 1 then hexprint <| byte (i + x - 1)
        else printf "   "
    )

    let view =
        dat |> slice y n_rows
            |> chop x n_cols

    let col_diff =
        [0..n_cols-1] |> List.map (fun i ->
            view |> List.map (List.tryItem i) 
                 |> List.distinct 
                 |> List.length
        )

    col_diff |> List.iteri (fun i x ->
        if x = 1 then
            Console.SetCursorPosition(6 + i * 3, 1)
            Console.ForegroundColor <- ConsoleColor.Green
            Console.Write(".")
            Console.ForegroundColor <- ConsoleColor.White
        else
            Console.SetCursorPosition(6 + i * 3, 1)
            Console.BackgroundColor <- ConsoleColor.Red
            Console.Write("!")
            Console.BackgroundColor <- ConsoleColor.Black
    )

            
    view
        |> List.iteri (fun i x -> 
        Console.SetCursorPosition(0, i + 2)
        printf "%03d   " (i + y)
        x |> List.iter hexprint
    )

    Console.SetCursorPosition(0, n_rows + 2)
    Console.WriteLine("============================================================")
    printfn "X = 0x%x" x
    printf  "Y = 0x%x" y

    let k = Console.ReadKey().Key
    match k with
    | ConsoleKey.Escape     -> ()
    | ConsoleKey.Spacebar   -> 
        Console.Clear()
        recall dat x y
    | ConsoleKey.LeftArrow  -> recall dat (x-1) y
    | ConsoleKey.RightArrow -> recall dat (x+1) y
    | ConsoleKey.UpArrow    -> recall dat x     (y-1)
    | ConsoleKey.DownArrow  -> recall dat x     (y+1)
    | ConsoleKey.PageDown   -> recall dat x     (y+n_rows)
    | ConsoleKey.PageUp     -> recall dat x     (y-n_rows)
    | ConsoleKey.Home       -> recall dat (x-n_cols) y
    | ConsoleKey.End        -> recall dat (x+n_cols) y
    | _                     -> recall dat x     y

let extract com patterns =
    patterns
 |> List.map (fun cmd -> 
    printfn "extracting %A" cmd
    let result = communicate com cmd
    printfn "result = %A" result
    result) 
 |> List.map JsonConvert.SerializeObject

let extract_patterns com patterns =
    [for i in patterns -> [ 0x64; i] ]
 |> extract com

let ``extract note pitch samples from B1 to B16`` com =
    (* The source data is B1-B16 running C4-D#5, track1. Other tracks are empty. *)
    printfn "Running B1-B16 extraction"
    let sources = [0x3C..0x4B] 
               |> List.mapi (fun i note -> 
                  Pattern('B', i, mkpattern (Track1 [o; mknote note; o; o; o; o; o; o; o; o; o; o; o; o; o; o;])))
    let results = extract_patterns com [0x10..0x1F]
    File.WriteAllLines("B1-B16_note_pitch.json", results)
    File.WriteAllLines("B1-B16_note_pitch.src.json", List.map JsonConvert.SerializeObject sources)
    
let ``extract trigger parameters from C5`` com =
    (* plain trigger, trig mute, accent, note slide, parameter slide, combinations. *)
    let to_bool x = if x = 0 then false else true
    let n a b c d e =
        {
            Active = to_bool e
            Mute = to_bool d
            Accent = to_bool c
            NoteSlide = to_bool b
            ParamSlide = to_bool a
            Note = C4
        }
    printfn "Running C5-C8 extraction"

    let triggers = [
         n 0 0 0 0 0
         n 0 0 0 0 1
         n 0 0 0 1 0
         n 0 0 0 1 1
         n 0 0 1 0 0
         n 0 0 1 0 1
         n 0 0 1 1 0
         n 0 0 1 1 1
         n 0 1 0 0 0
         n 0 1 0 0 1
         n 0 1 0 1 0
         n 0 1 0 1 1
         n 0 1 1 0 0
         n 0 1 1 0 1
         n 0 1 1 1 0
         n 0 1 1 1 1
         // ----
         n 1 0 0 0 0
         n 1 0 0 0 1
         n 1 0 0 1 0
         n 1 0 0 1 1
         n 1 0 1 0 0
         n 1 0 1 0 1
         n 1 0 1 1 0
         n 1 0 1 1 1
         n 1 1 0 0 0
         n 1 1 0 0 1
         n 1 1 0 1 0
         n 1 1 0 1 1
         n 1 1 1 0 0
         n 1 1 1 0 1
         n 1 1 1 1 0
         n 1 1 1 1 1
         ]
    let no_triggers = List.init 32 (fun _ -> n 0 0 0 0 0)
    let p i trks = Pattern('C', i - 1, {mkpattern (Tracks trks) with Scale = scale_32} )
    let sources  = [
        p 5 [triggers; no_triggers]
        p 6 [no_triggers; triggers]
        p 7 [triggers; triggers]
        p 8 [no_triggers; no_triggers]
    ]
    let results = extract_patterns com [ 0x24..0x27 ]
    File.WriteAllLines("C5_trigger_variations.json", results)
    File.WriteAllLines("C5_trigger_variations.src.json", List.map JsonConvert.SerializeObject sources)

let ``extract sounds`` com =
    (* The source data is sound patch 0 to 103 from pool used for identifying param positions. *)
    printfn "Running sound extraction"
    let results = extract com [for i in 0..103 -> [0x63; i]]
    File.WriteAllLines("sounds.json", results)


let read_records filename =
    File.ReadLines(filename)
  |>Seq.map JsonConvert.DeserializeObject<CommunicationRecord>
  |>Seq.map (fun x -> x.response)
  |>List.ofSeq

type SoundInferResult = 
    {
        Id:   int
        Name: string
        Diff: (int * byte * byte) list
    }

let ``infer sound params`` () =
    // first effective parameter payload is at 0x2b
    // 7bit codec start from 0x12
    let base_patch :: patches = read_records "sounds.json"

    let fix offset _from _to = List.mapi ( fun i x -> if i = offset && x = (byte _from) then (byte _to) else x )
    // fix some incorrect samplings -- some params are changed mistakenly (encoder too sensitive)
    // $0xa1 should be 00 or 7F but some are 1
    // $0xbd should not be 03. (base=02, patch=06)
    let fixes = 
        fix 0xa1 1 0
     >> fix 0xbd 3 2
    let patches = List.map fixes patches

    let inferer (pid: int) 
                (p: byte list) =
        let zip   = List.zip base_patch p |> List.mapi (fun i (a,b) -> (i,a,b))
        let diff  = zip 
                 |> List.choose (fun ((i,a,b) as x) -> 
                                 if a<>b && i >= 0x2b && i < 410 &&
                                    // accidentally tweaked some mod settings. filter them
                                    // until we're rampling the mod settings.
                                    (pid >= 100 || i < 0x122)  
                                 then Some x 
                                 else None)

        // attach nearby MSBs
        let ((offset_h, _, _), (offset_t, _, _))  =(diff.Head, List.last diff)
        let msbs  = zip
                 |> List.choose (fun ((i,a,b) as x) -> 
                                 if i >= 0x2b && i >= offset_h - 4 && i <= offset_t + 4
                                 then Some x 
                                 else None)

        let diff = diff @ msbs
                |> List.sortBy (fun (i,_,_) -> i)
                |> List.distinct

        {
            Id = pid + 1
            Name = SoundPatches.[pid]
            Diff = diff
        }
    let fmt_result {Id=pid; Name=name; Diff=diff} =
        let inline fmt_seq (x: ^T list) = String.Join(" ", List.map (sprintf "%04x") x)
        let offset, _base, patch  = List.unzip3 diff
        let content = [ 
            "-------------------------------------"
            sprintf "Patch #%03d: %s" pid name
            sprintf "Indicator: %s" (String.Join(" ", List.map (fun (x,a,b) -> if (x-0x12) % 8 = 0 then "x   " elif a<>b then "vvvv" else "    ") diff))
            sprintf "Offset:    %s" (fmt_seq offset)
            sprintf "Base:      %s" (fmt_seq _base)
            sprintf "Patch:     %s" (fmt_seq patch)
            ""
        ]
        String.Join("\n", content)

    let results = 
        List.mapi inferer patches
        |> List.sortBy (fun x -> 
            let o0, _, _ = List.find (fun (_,a,b) -> a<>b) x.Diff
            o0)
        |> List.map (fmt_result)
    File.WriteAllLines("sounds.inference.txt", results)

let ``serial monitor`` (com: SerialPort) =
  let mutable cur = 0
  while true do
    try 
      let b = com.ReadByte() |> byte
      printf "%02X" b
      cur <- cur + 1
      if cur < 16 then
        printf " "
      else
        cur <- 0
        printfn ""
    with | :? TimeoutException -> ()

[<EntryPoint>]
let main argv =
    use com = new SerialPort("COM4", 250000)
    com.ReadTimeout <- 100
    com.Open()

    let mutable argv = List.ofArray argv

    match argv with
    | "a4" :: rest ->
        argv <- rest
        dev <- AnalogFour
    | "mono" :: rest ->
        argv <- rest
        dev <- MonoMachine
    | _ -> ()

    match argv with
    | [ "analyze"; filename ] ->
        let data = read_records filename
        Console.Clear()
        recall data 0 0
    | [ "B1-B16" ] -> 
        ``extract note pitch samples from B1 to B16`` com
    | [ "C5" ] -> 
        ``extract trigger parameters from C5`` com
    | [ "sound" ] -> 
        ``extract sounds`` com
    | [ "monitor" ] -> 
        ``serial monitor`` com
    | [ "infer_snd" ] -> 
        ``infer sound params`` ()
    | [ "collect" ]
    | _ ->
        let results = 
            probe com [] 0x40 1 (Fixed([], 0))
            |> List.map JsonConvert.SerializeObject
        File.AppendAllLines("records.json", results)
    

    0 // return an integer exit code
